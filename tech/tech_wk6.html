<!DOCTYPE html>
<html>

<head>
    <title>Boatz'n'Blogz</title>
    <link rel="stylesheet" href="../bootstrap-3.2.0-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../stylesheets/index.css">
    <link rel="stylesheet" href="../stylesheets/blog.css">
    <meta name="viewport" content="width=device-width">
</head>

<body class="bg-img">

    <!-- _______________Bootstrap Nav _____________ -->
    <nav class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="../index.html">Boatz 'n' Blogz</a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li class="active"><a href="../index.html#tech">Tech</a>
                    </li>
                    <li><a href="../index.html#culture">Culture</a>
                    </li>
                    <li><a href="../projects/jungle_joe.html">Projects</a>
                    </li>
                    <!-- Contact Dropdown -->
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contact <span class="caret"></span></a>
                        <ul class="dropdown-menu" role="menu">
                            <li><a href="https://plus.google.com/117925567488555774987/posts">Google+</a>
                            </li>
                            <li><a href="https://github.com/sspread">GitHub</a>
                            </li>
                            <li><a href="https://www.linkedin.com/pub/sam-spread/1a/a20/396">LinkedIn</a>
                            </li>
                            <li><a href="https://twitter.com/scspread">Twitter</a>
                            </li>
                        </ul>
                    </li>
                </ul>
                <!-- RIGHT SIDE NAV POST TOGGLE -->
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="tech_wk7.html">
                            <span class="glyphicon glyphicon-chevron-left"></span>Later Post</a>
                    </li>
                    <li><a href="tech_wk5.html">Earlier Post<span class="glyphicon glyphicon-chevron-right"></span></a>
                    </li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container-fluid -->
    </nav>

    <!-- _________________End Bootstrap Nav_________________ -->

    <div class="col-sm-9">

        <article>
            <h2>Proc Party</h2>
            <h4><small>July 29.2014</small></h4>

                <p>Blocks, Procs and lambdas are instrumental function syntax in Ruby. After doing some due dilligence, I find it proper to extend to you my basic understanding of these guys. The differences between these <i>closures</i> are rather subtle and I sometimes wish there was only one type. But there are at least three. All three belong to the
                    <span class="code">Proc</span>class, as in <i>proc</i>edure. This is very important.</p>

                <h4>Blocks</h4>
                <p>Blocks are syntax literals for Proc objects. As such, you can create a block with curlies
                    <span class="code">{}</span>(single line) or with
                    <span class="code">do...end</span>. The code example below illustrates two ways to call the block from a method, and feed it an argument.</p>

                <img class="image_full" src="../images/blocks.PNG">
                <br>
                <p class="code">
                    block_call {|n| puts "I'm in the #{n}."}
                    <span class="output">
                        <br>=> I'm before the block.
                        <br>=> I'm in the block.
                        <br>=> I'm after the block.
                    </span>
                </p>

                <p>Blocks are easy to code on the fly, but there's another way to create Procs that allows us to save our snippets to objects.</p>

                <h4>Procs</h4>
                <p>Although blocks actually are Procs, Procs behave a little differently when explicitly created with
                    <span class="code">Proc.new</span>.</p>

                <img class="image_full" src="../images/procs.PNG">
                <br>
                <p class="code">
                    proc_call(where_r_u)
                    <br>puts
                    <br>proc_call_vip(where_r_u)
                    <span class="output">
                        <br>=> I'm before the proc.
                        <br>=> I'm in the proc, dummy!
                        <br>=> I'm in the proc, fool!
                        <br>=> I'm in the proc, doofus!
                        <br>=> I'm after the proc.
                        <br>=>
                        <br>=> I'm before the proc.
                        <br>=> I'm in the VIP section, dummy!
                        <br>=> I'm in the VIP section, fool!
                        <br>=> I'm in the VIP section, doofus!
                        <br>=> I'm after the proc.
                    </span>
                </p>

                <p>Our
                    <span class="code">where_r_u</span> Proc is a little rude, but he's DRY because we only have to define him once and can use him forever.</p>

                <h4>Lambdas</h4>
                <p>Finally, creating a Proc with the keyword
                    <span class="code">lambda</span> makes for even a slightly different Proc. Lambdas have two key differences from the Procs I described above. The first is that a lambda actually cares about the number of arguments passed to it. &iexcl;Mira!</p>

                <p class="code">
                    proq = proc {|x,y| "#{x} y #{y}"}
                    <br>lamb = lambda {|x,y| "#{x} y #{y}"}
                    <br>
                    <br>puts proq.call('uno','dos')
                    <br>
                    <span class="output">=> uno y dos</span>
                    <br>puts proq.call('uno')
                    <br>
                    <span class="output">=> uno y</span>
                    <br>puts lamb.call('uno','dos')
                    <br>
                    <span class="output">=> uno y dos</span>
                    <br>puts lamb.call('uno')
                    <br>
                    <span class="output">=> 'block in (main)': wrong number of arguments (1 for 2) (ArgumentError)</span>
                </p>

                <p>On second thought, using Spanish with these particular variable letters may have added unfair befuddlement to this example, but I hope you get it.
                    <span class="code">lambda</span>will throw a fuss if you neglect an argument, and
                    <span class="code">Proc.new</span>(equivalent to
                    <span class="code">proc</span>) will throw your shit into a bag and push it down the stairs. Because it don't care.</p>

                <p>The other difference is in the way lambdas and Procs treat
                    <span class="code">return</span>.
                    <span class="code">lambda</span>returns only from itself, while
                    <span class="code">proc</span>returns from itself <i>and</i> from the method from whence it came. Looksee!</p>

                <img class="image_full" src="../images/return.PNG">
                <br>
                <p class="code">
                    puts who_r_u ima_lambda
                    <br>puts
                    <br>puts who_r_u ima_lambda, 1
                    <span class="output">
                        <br>=> Who are you Procs?
                        <br>=> I'm a lamb, duh!
                        <br>=> Who's your friend?
                        <br>=> I'm a Proc!
                        <br>=>
                        <br>=> Who are you Procs?
                        <br>=> I'm a Proc!
                    </span>
                </p>

                <p>When the lambda is executed first within
                    <span class="code">#who_r_u</span>, the rest of the method's code is executed. However, when the Proc is executed first, its
                    <span class="code">return</span>skips the remainder of the method's code. Also worth noting in this example, Ruby does not allow arguments containing
                    <span class="code">return</span>, so I had to define
                    <span class="code">ima_proc</span>within our method. However, lambdas can magically get away with it, so
                    <span class="code">ima_lambda</span>is defined outside the method and passed in as an argument.</p>

                <p>And that's all I have for you.</p>

                <footer>--- Week 6 ---</footer>
            </span>
        </article>

    </div>

    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="../bootstrap-3.2.0-dist/js/bootstrap.min.js"></script>
</body>

</html>
